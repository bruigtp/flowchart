p1 <- dat_pm25 %>%
filter(mun != "MA", lags != "Overall") %>%
mutate(
mun = factor(mun, levels = rev(unique(mun)))
) %>%
ggplot(aes(x = factor(lags), y = mun, fill = RRfit)) +
geom_tile() +
scale_fill_gradient2(name = "RR", midpoint = log(1), low = "#009392", mid = "#f6edbd", high = "#cf597e", trans = "log10") +
# scale_fill_carto_c(name = "%", palette = "BurgYl") +
labs(x = "", y = "") +
theme_classic() +
theme(legend.position = "top", legend.key.width=unit(1,"cm"))
#Extract the legend (to arrange it in a proper way)
legend <- get_legend(p1)
p1 <- p1 + theme(legend.position = "none")
#Extract the labels (to arrange it)
#
# labels1 <- cowplot::ggdraw(cowplot::get_y_axis(p1))
# p1 <- p1 + theme(
#   axis.line.y = element_blank(),
#   axis.ticks.y= element_blank(),
#   axis.text.y= element_blank(),
#   axis.title.y= element_blank()
# )
#Plot in the margin right
p2 <- dat_pm25 %>%
filter(mun != "MA", lags == "Overall") %>%
mutate(
mun = factor(mun, levels = rev(unique(mun)))
) %>%
ggplot(aes(y = mun)) +
geom_point(aes(x = RRfit)) +
geom_linerange(aes(xmin = RRlow, xmax = RRhigh)) +
geom_segment(x = 0, xend = 0, y = 0, yend = 16.5, color = "black", linetype = "dashed") +
scale_x_continuous(trans = "log10", breaks = seq(0.95, 1.05, by = 0.05)) +
labs(x = "", y = "") +
theme_classic() +
theme(axis.line.y = element_blank(),
axis.ticks.y= element_blank(),
axis.text.y= element_blank(),
axis.title.y= element_blank())
#Create a blank plot for the sake of the grid.arrange
blankPlot <- ggplot()+geom_blank(aes(1,1)) + cowplot::theme_nothing()
#Plot in the bottom
p3 <- dat_pm25 %>%
filter(mun == "MA", lags != "Overall") %>%
mutate(lags = gsub("Lag ", "", lags),
lags = factor(lags, levels = 0:14)) %>%
ggplot(aes(x = lags)) +
geom_line(aes(y = RRfit)) +
geom_linerange(aes(ymin = RRlow, ymax = RRhigh)) +
geom_line(aes(y = RRfit), group = 1) +
geom_hline(yintercept = 1, color = "black", linetype = "dashed") +
scale_y_continuous(trans = "log10", breaks = seq(0.98, 1.04, by = 0.02), labels = str_glue("{str_dup(' ', 16)}{seq(0.98, 1.04, by = 0.02)}")) +
labs(x = "", y = "") +
theme_classic()
#Extract the labels (to arrange it)
#
# labels3 <- cowplot::ggdraw(cowplot::get_y_axis(p3))
# p3 <- p3 + theme(
#   axis.line.y = element_blank(),
#   axis.ticks.y= element_blank(),
#   axis.text.y= element_blank(),
#   axis.title.y= element_blank()
# )
#Juntem els gràfics:
grid.arrange(legend, blankPlot, p1, p2, p3, blankPlot, nrow = 3, ncol = 2,
heights = c(0.4, 1.5, 0.7),
widths = c(80, 20))
#Save plot
png(r"(S:\Bioestadistica\2023_09ONAIR\4_Productes\2_Figures\Heatmap\heatmap_pm25.png)",width = 6000,height = 4000,res = 600)
grid.arrange(legend, blankPlot, p1, p2, p3, blankPlot, nrow = 3, ncol = 2,
heights = c(0.4, 1.5, 0.7),
widths = c(80, 20))
dev.off()
#Heatmap for city
p1 <- dat_no2 %>%
filter(mun != "MA", lags != "Overall") %>%
mutate(
mun = factor(mun, levels = rev(unique(mun)))
) %>%
ggplot(aes(x = factor(lags), y = mun, fill = RRfit)) +
geom_tile() +
scale_fill_gradient2(name = "RR", midpoint = log(1), low = "#009392", mid = "#f6edbd", high = "#cf597e", trans = "log10") +
# scale_fill_carto_c(name = "%", palette = "BurgYl") +
labs(x = "", y = "") +
theme_classic() +
theme(legend.position = "top", legend.key.width=unit(1,"cm"))
#Extract the legend (to arrange it in a proper way)
legend <- get_legend(p1)
p1 <- p1 + theme(legend.position = "none")
#Extract the labels (to arrange it)
#
# labels1 <- cowplot::ggdraw(cowplot::get_y_axis(p1))
# p1 <- p1 + theme(
#   axis.line.y = element_blank(),
#   axis.ticks.y= element_blank(),
#   axis.text.y= element_blank(),
#   axis.title.y= element_blank()
# )
#Plot in the margin right
p2 <- dat_no2 %>%
filter(mun != "MA", lags == "Overall") %>%
mutate(
mun = factor(mun, levels = rev(unique(mun)))
) %>%
ggplot(aes(y = mun)) +
geom_point(aes(x = RRfit)) +
geom_linerange(aes(xmin = RRlow, xmax = RRhigh)) +
geom_segment(x = 0, xend = 0, y = 0, yend = 16.5, color = "black", linetype = "dashed") +
scale_x_continuous(trans = "log10") +
labs(x = "", y = "") +
theme_classic() +
theme(axis.line.y = element_blank(),
axis.ticks.y= element_blank(),
axis.text.y= element_blank(),
axis.title.y= element_blank())
#Create a blank plot for the sake of the grid.arrange
blankPlot <- ggplot()+geom_blank(aes(1,1)) + cowplot::theme_nothing()
#Plot in the bottom
p3 <- dat_no2 %>%
filter(mun == "MA", lags != "Overall") %>%
mutate(lags = gsub("Lag ", "", lags),
lags = factor(lags, levels = 0:14)) %>%
ggplot(aes(x = lags)) +
geom_line(aes(y = RRfit)) +
geom_linerange(aes(ymin = RRlow, ymax = RRhigh)) +
geom_line(aes(y = RRfit), group = 1) +
geom_hline(yintercept = 1, color = "black", linetype = "dashed") +
scale_y_continuous(trans = "log10", breaks = seq(1, 1.04, by = 0.02), labels = str_glue("{str_dup(' ', 50)}{seq(1, 1.04, by = 0.02)}")) +
labs(x = "", y = "") +
theme_classic()
#Extract the labels (to arrange it)
#
# labels3 <- cowplot::ggdraw(cowplot::get_y_axis(p3))
# p3 <- p3 + theme(
#   axis.line.y = element_blank(),
#   axis.ticks.y= element_blank(),
#   axis.text.y= element_blank(),
#   axis.title.y= element_blank()
# )
#Juntem els gràfics:
grid.arrange(legend, blankPlot, p1, p2, p3, blankPlot, nrow = 3, ncol = 2,
heights = c(0.4, 1.5, 0.7),
widths = c(80, 20))
#Save plot
png(r"(S:\Bioestadistica\2023_09ONAIR\4_Productes\2_Figures\Heatmap\heatmap_no2.png)",width = 6000,height = 4000,res = 600)
grid.arrange(legend, blankPlot, p1, p2, p3, blankPlot, nrow = 3, ncol = 2,
heights = c(0.4, 1.5, 0.7),
widths = c(80, 20))
dev.off()
View(dat_pm10)
trail
trial
library(epiR)
#Llibreries
library(kableExtra) # per utilitzar kable
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(stringr)
library(captioner) # enumera taules i figures
library(lme4) #models  Mixtes
library(sjPlot)
library(RColorBrewer) #paletes de colors
library(ggplot2)
library(grid)
library(gridExtra)
library(readxl)
library(gtsummary)
library(psych)
library(PerformanceAnalytics)
library(factoextra)
library(kmed)
library(fpc)
library(rcartocolor)
library(patchwork)
library(cluster)
library(vcd)
library(corrplot)
library(patchwork)
library(cobalt)
# library(flowchart)
#Enumerar taules i figures
fig_nums <- captioner(prefix = 'Figura')
tab_nums <- captioner(prefix = 'Tabla')
###############
#Dades
################
setwd('S:/Bioestadistica/2023_11ENegredo')
dades_ana<-'./2_Dades/2_Analisi'
Funcions<-'I:/CTebe/3_CodiR/Funcions'
Themes<-'I:/CTebe/3_CodiR/Themes'
#Source functions:
source(file.path(Funcions, 'flowchart.R'))
#Source themes:
source(file.path(Themes, 'gtsummary_theme_brui.R'))
reset_gtsummary_theme()
set_gtsummary_theme(theme_brui)
trial %>% tbl_summary()
# Chunk 1
rm(list=ls())
# #Package renv (restore package versions):
# codiR <- "S:/Bioestadistica/2023_11ENegredo/3_CodiR"
# renv::init(codiR) #To generate a copy of the package versions (first time)
# renv::snapshot(codiR) #To regenerate the copy if we change or update any library (recommended to use at the end of the analysis)
# renv::restore(codiR) #To restore the package versions (for the future)
library(epiR)
#Llibreries
library(kableExtra) # per utilitzar kable
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(stringr)
library(captioner) # enumera taules i figures
library(lme4) #models  Mixtes
library(sjPlot)
library(RColorBrewer) #paletes de colors
library(ggplot2)
library(grid)
library(gridExtra)
library(readxl)
library(gtsummary)
library(psych)
library(PerformanceAnalytics)
library(factoextra)
library(kmed)
library(fpc)
library(rcartocolor)
library(patchwork)
library(cluster)
library(vcd)
library(corrplot)
library(patchwork)
library(cobalt)
# library(flowchart)
#Enumerar taules i figures
fig_nums <- captioner(prefix = 'Figura')
tab_nums <- captioner(prefix = 'Tabla')
###############
#Dades
################
setwd('S:/Bioestadistica/2023_11ENegredo')
dades_ana<-'./2_Dades/2_Analisi'
Funcions<-'I:/CTebe/3_CodiR/Funcions'
Themes<-'I:/CTebe/3_CodiR/Themes'
#Source functions:
source(file.path(Funcions, 'flowchart.R'))
#Source themes:
source(file.path(Themes, 'gtsummary_theme_brui.R'))
reset_gtsummary_theme()
set_gtsummary_theme(theme_brui)
#Load data & dictionary
load(file.path(dades_ana, "data_v5.Rda"))
load(file.path(dades_ana, "dic_v2.Rda"))
load(file.path(dades_ana, "event_form.Rda"))
#Load data dictionary
var_lab <- read_excel("3_CodiR/var_lab.xlsx")
sdata <- data %>%
filter(is.na(redcap_repeat_instance), (n_visit == 2 & redcap_event_name == "valoracin_2_arm_1") | (n_visit == 1 & redcap_event_name == "valoracin_1_arm_1")) %>%
select(
"Barthel" = alterado_bar,
"Lawton" = alterado_law,
"Auditive" = alterado_def,
"Urinary" = alterado_inc, #molts missings,
"Pittsburg" = alterado_pit,
"Pfeiffer" = alterado_pfe2,
"Fried" = alterado_fri, #molts missings
"SPPB" = alterado_spp,
"MNA" = alterado_mna,
"Barber" = alterado_barb,
"FAC" = alterado_fac,
"Depression" = alterado_depre_psi,
"Complain" = alterado_qj_psi,
"NEU-Screen" = neu_psi_alt
) %>%
mutate_all(~factor(tolower(.x), levels = c("no alterado", "alterado")))
#Heatmap:
sdata_p2 <- tibble(expand.grid(x = names(sdata), y = names(sdata))) %>%
mutate(
alter = map2_dbl(x, y, function(s1, s2) {
df <- sdata %>%
select(all_of(c(s1, s2))) %>%
na.omit()
N <- nrow(df)
n <- sum(df[[s1]] == df[[s2]])
n*100/N
})
) %>%
pivot_wider(names_from = y, values_from = alter) %>%
column_to_rownames(var = "x") %>%
as.matrix()
corrplot(sdata_p2, type="upper", col = carto_pal(100, "SunsetDark"), is.corr = FALSE, col.lim = c(0, 100))
rm(list = ls())
library("devtools")
library(roxygen2)
setwd(r"(I:\CTebe\2_Projectes\2024_02Flowchart\3_CodiR\flowchart)")
#To create the package: https://www.r-bloggers.com/2020/07/how-to-write-your-own-r-package-and-publish-it-on-cran/
#1. Create an R project to a new existing directory and select R package
#2. Write a script for each function providing all information.
#3. Write a script for each built-in dataset, and save them in a data/ folder.
#4. Copy the license MIT file (from an existing package or https://www.r-project.org/Licenses/) and add this to .Rbuildignore: ^LICENSE\.md$
#5. Modify DESCRIPTION.md with the information about this package.
#6. Write a NEWS.md in which we will write the news from each update: usethis::use_news_md()
#7. Write a vignette: usethis::use_vignette("NAME_VIGNETTE")
#8. Specify all of the packages that we have to use:
# purrr::map(c("Gmisc", "grid", "tidyr", "dplyr", "purrr", "stringr", "tibble", "rlang"), usethis::use_package)
#usethis::use_pipe()
# Follow the next steps (we will also have to follow them in each update):
devtools::document()
devtools::check()
# devtools::check(vignettes = FALSE) # Check
rm(list = ls())
library("devtools")
library(roxygen2)
setwd(r"(I:\CTebe\2_Projectes\2024_02Flowchart\3_CodiR\flowchart)")
#To create the package: https://www.r-bloggers.com/2020/07/how-to-write-your-own-r-package-and-publish-it-on-cran/
#1. Create an R project to a new existing directory and select R package
#2. Write a script for each function providing all information.
#3. Write a script for each built-in dataset, and save them in a data/ folder.
#4. Copy the license MIT file (from an existing package or https://www.r-project.org/Licenses/) and add this to .Rbuildignore: ^LICENSE\.md$
#5. Modify DESCRIPTION.md with the information about this package.
#6. Write a NEWS.md in which we will write the news from each update: usethis::use_news_md()
#7. Write a vignette: usethis::use_vignette("NAME_VIGNETTE")
#8. Specify all of the packages that we have to use:
# purrr::map(c("Gmisc", "grid", "tidyr", "dplyr", "purrr", "stringr", "tibble", "rlang"), usethis::use_package)
#usethis::use_pipe()
# Follow the next steps (we will also have to follow them in each update):
devtools::document()
devtools::check()
setwd(r"(I:\CTebe\2_Projectes\2024_02Flowchart\3_CodiR\flowchart)")
# available::available("REDCapDM", browse = FALSE)
# devtools::spell_check()
# devtools::install_deps()
rhub::check_for_cran()
rm(list=ls())
########################
#Llibreries
########################
library(tidyr)
library(tibble)
library(dplyr)
library(purrr)
library(stringr)
library(lubridate)
library(janitor)
library(openxlsx)
library(data.table)
########################
## Funcions
########################
setwd('S:/Bioestadistica/2023_18CReyes')
# setwd(R"(C:\Users\psatorra\Documents\2023_18CReyes)")
########################
## Directoris
########################
dades<-"./2_Dades/1_Originals"
dades_ana<-"./2_Dades/2_Analisi"
#------Diagnostics---------
#Database containing all the adverse events.
dat_diag <- readRDS(file.path(dades_ana, "OPIOIDES_entregable_problemes_20190903_130032.rds"))
# #For WP1, the outcome comorbidity for which the opioid was prescribed has to be defined for the following diagnostics: osteoarthritis, back pain, neck/shoulder pain, fibromyalgia, bone fractures, major surgeries, cancer, other msk disorder/s (hem considerat OTH_MUCSKEDIS, AR - ho especifica literalment- i OSTP)
# comors <- c("OSTEOARTR", "BACKPAIN", "NECKPAIN", "FMIALGIA", "FRACT", "SURGERY", "CANCER_C", "OTH_MUSCSKEDIS", "AR", "OSTP", "Other")
# lab <- c("Osteoarthritis", "Back pain", "Neck/shoulder pain", "Fibromyalgia", "Bone fractures", "Major surgeries", "Cancer", rep("Other muscoskeletal disorder/s", 3), "Other")
# dat_diag[, comor := ifelse(agr %in% comors, agr, "Other")]
# dat_diag[, comor:= factor(comor, levels = comors, labels = lab)]
#For WP2, only the following AEs will be analysed: 1.	Cardiac arrhythmia, 2. Delirium, 3.	Fractures (hip, pelvis, wrist, humerus), 4. Falls, 5. Sleep disorders (sleep apnea, somnolence), 6. Constipation, 7. Opioid dependence/abuse, 8. All-cause mortality. Only the AEs occurring during the exposure period will be considered.
#Recode AEs of interest for the analysis
aes <- c("ARRIT", "DELIRI", "FRACT", "FALLS", "SLEEPDIS", "CONSTIP", "DEPOPIOID", "ABUSOPIOID", "DEATH")
lab <- c("Cardiac arrhythmia", "Delirium", "Fractures (hip, pelvis, wrist, humerus)", "Falls", "Sleep disorders (sleep apnea, somnolence)", "Constipation", rep("Opioid dependence/abuse", 2), "All-cause mortality")
dat_diag[, ae := factor(agr, levels = aes, labels = lab)]
#Some will be considered as potential confounders: cancer before cohort entry (except skin cancer without metastasis - no sé si està inclòs a CANCER_C o no-), pulmonary oedema at cohort entry, peripheral vascular disease on or before cohort entry, diabetes (type I and II) on or before cohort entry, Irritable bowel on or before cohort entry (no ho trobo, tampoc buscant pels codis individuals que fica al protocol que són K58 i K58.9!!), diarrhoea at cohort entry, malabsorption disorders at cohort entry, COPD on or before cohort entry, chronic cough at cohort entry, neurologic pathologies (migrane) at cohort entry, burn injuries at cohort entry, Chronic musculoskeletal pain disorders on or before cohort entry (mirant la taula del protocol veiem que coincideix amb els agrupadors OSTP, OSTEOARTR and OTH_MUSCSKED. BACKPAIN i NECKPAIN no entrarien, no?), Rheumatological disorders on or before cohort entry (artritis reumatoide), cardiovascular events (cardiac insufficiency, myocardial ischemia, angina, stroke, TIA) at cohort entry, Alzheimer and Parkinson on or before cohort entry, Chronic liver and kidney disease on or before cohort entry, Charlson Comorbidity Index (però això no és un diagnòstic, que vol dir que algú tingui CCI?? No ho incluim,l'haurem de calcular nosaltres), Procedures: major surgeries at cohort entry, Traffic accidents during the exposure period (ho recollim després perquè hem de tenir en compte l'exposure period)
confusors <- c("PULMEDEM", "PERIVASC", "DM", "DIARREA", "MALAB", "EPOC", "COUGH", "MIGRANA", "BURN", "OSTEOARTR", "OSTP", "OTH_MUSCSKEDIS", "AR", "ANGPEC", "ARRIT", "CARDIACINSUF", "MI", "STROKE", "TIA", "ALZHEIM", "PARKISME", "CKD", "CLD")
lab <- c("Pulmonary oedema", "Peripheral vascular disease", "Diabetes (type I and II)", "Diarrhoea", "Malabsorption disorders", "COPD", "Chronic cough", "Neurologic pathologies (migrane)", "Burn injuries", rep("Chronic musculoskeletal pain disorders", 3), "Rheumatological disorders", rep("Cardiovascular events", 6), "Alzheimer", "Parkinson", "Chronic kidney disease", "Chronic liver disease")
dat_diag[, conf := factor(agr, levels = confusors, labels = lab)]
dat_diag[, `:=`(dat = ymd(dat), dbaixa = ymd(dbaixa))]
dat_pop1 <- readRDS(file.path(dades_ana, "OPIOIDES_entregable_poblacio_20190903_130032.rds"))
#Date variables as date
date_vars <- c("dnaix", "entrada", "sortida")
dat_pop1[, (date_vars) := lapply(.SD, ymd), .SDcols = date_vars]
#Recode sex
dat_pop1[, sexe := factor(sexe, levels = c("D", "H"), labels = c("Female", "Male"))]
#Create exitus variable. La T és trasllat però la A què és?
dat_pop1[, exitus := factor(case_match(situacio, c("A", "T") ~ 0, "D" ~ 1), levels = 0:1, labels = c("No", "Yes"))]
#We cannot add one year to the 29 of February
dat_pop1[, entrada2 := case_when(format(entrada, "%m-%d") == "02-29" ~ entrada + 1, TRUE ~ entrada)]
#Start date: latest of one year of valid data or the study period
dat_pop1[, start := pmax(entrada2 + lubridate::years(1), ymd("2007-01-01"))]
#End date: earliest of the enrolment (due to moving or death) or the date of last data capturing
dat_pop1[, end := pmin(sortida, ymd("2019-12-31"))]
#Difference between start and end (duration of study)
dat_pop1[, t_study := end - start]
#Create age at start date
dat_pop1[, age := time_length(lubridate::interval(dnaix, start), "years")]
#Group age
dat_pop1[, age_cat := case_when(
age < 18 ~ NA,
age < 44 ~ 1,
age < 64 ~ 2,
TRUE ~ 3
)]
dat_pop1[, age_cat := factor(age_cat, levels = 1:3, labels = c("18-44", "44-64", "64+"))]
#Modifiquem la data final en funció de si té un diagnòstic de càncer (s'haurà d'excloure a partir del diagnòstic)
dat_cancer_exc <- dat_diag[agr == "CANCER_C",]
dat_cancer_exc <- dat_cancer_exc[, .(d_cancer = min(dat)), by = "idp"]
dat_pop1 <- merge(dat_pop1, dat_cancer_exc, all.x = TRUE)
dat_pop1[, end_cancer := pmin(end, d_cancer, na.rm = TRUE)]
#Difference between start and end considering cancer
dat_pop1[, t_study_cancer := end_cancer - start]
dat_se <- readRDS(file.path(dades_ana, "OPIOIDES_entregable_variables_socioeconomiques_20190903_130032.rds"))
#Recode qmedea ("" to missing)
dat_se[, qmedea := factor(qmedea, levels = c("U1", "U2", "U3", "U4", "U5"))]
#Recode rural
# dat_se[, ruralitat := factor(ruralitat, levels = c("U", "R"), labels = c("Urban", "Rural"))]
#-----Clinical variables-----
#Information about the Alcohol, BMI and some clinical scores (EUROQOL, MMSE, PFEIFFER). These characteristics will have to be described at the time of first opioid dispensation, except to the BIM that has to be the closest to the cohort entry in the previous 3 years (no acabo d'entendre a què es refereix).
dat_clinic <- readRDS(file.path(dades_ana, "OPIOIDES_entregable_variables_cliniques_20190903_130032.rds"))
#Date variables as date
dat_clinic[, dat := ymd(dat)]
dat_farm <- readRDS(file.path(dades_ana, "OPIOIDES_entregable_facturacio_20190903_130032.rds"))
# id_farm_all <- dat_farm$idp
# #Send to Carlen the different codes that we have:
# pharma_codes <- unique(dat_farm[, c("cod", "agr")]) %>%
#   arrange(agr, cod)
# openxlsx::write.xlsx(pharma_codes, r"(S:\Bioestadistica\2023_18CReyes\4_Productes\4_Queries\pharma_codes.xlsx)")
#Date variables as date
dat_farm[, dat := ymd(dat)]
#Separate between mild opioids (tramadol/codeina) and morfina, fentanilo. The remaining opioids will be used to exclude dispensations with mixed dispensation:
# N02AA01- Morfina
# N02AB03 - fentanilo
# N02AX02- tramadol
# R05DA04- codeina
#
# combinaciones:
# N02AJ06- codeina con paracetamol
# N02AJ08- codeina con iburprofeno
# N02AJ13- tramadol con paracetamol
# N02AJ14- tramadol dexketoprofeno
dat_farm[, group := case_when(
agr == "NO_ANTI_INFLMA" ~ 1,
agr == "NSAID" ~ 2,
cod %in% c("N02AX02", "R05DA04") ~ 3,
cod == "N02AA01" ~ 4,
cod == "N02AB03" ~ 5,
TRUE ~ NA
)][, group := factor(group, levels = 1:5, labels = c("No anti-inflamatorios", "AINES", "Opioides débiles", "Morfina", "Fentanilo"))]
View(unique(dat_farm[,c("cod", "agr")]))
dat_farm_conf <- dat_farm[agr == "CONFUS"]
#Confusor medications: hypnotics (N05C), benzodiazepines (N05B), aspirin (B01AC06????? No el trobo, està només a fàrmacs prescrits!!), SSRI (N06AB) and anticonvulsant (N03)
dat_farm_conf[, `:=` (hypnotics = grepl("^N05C", cod),
benzo = grepl("^N05B", cod),
ssri = grepl("^N06AB", cod),
anticonv = grepl("^N03", cod))
]
#Filter only these medications (són totes!!)
dat_farm_conf <- dat_farm_conf[hypnotics | benzo | ssri | anticonv,]
#Add study entry date:
dat_farm_conf <- merge(dat_farm_conf, dat_pop1[, c("idp", "start")], all.x = TRUE)
#Filter only those in cohort entry (confirmar!!)
dat_farm_conf <- dat_farm_conf[start %within% interval(dat, d_end),]
# #Duration of treatment: the duration of all is 1 month, the duration of fentanilo is 15 days
dat_farm[, d_end := case_when(
group == "Fentanilo" ~ dat + 15,
TRUE ~ dat + 30
)]
dat_farm
dat_farm_conf <- dat_farm[agr == "CONFUS"]
#Confusor medications: hypnotics (N05C), benzodiazepines (N05B), aspirin (B01AC06????? No el trobo, està només a fàrmacs prescrits!!), SSRI (N06AB) and anticonvulsant (N03)
dat_farm_conf[, `:=` (hypnotics = grepl("^N05C", cod),
benzo = grepl("^N05B", cod),
ssri = grepl("^N06AB", cod),
anticonv = grepl("^N03", cod))
]
#Filter only these medications (són totes!!)
dat_farm_conf <- dat_farm_conf[hypnotics | benzo | ssri | anticonv,]
#Add study entry date:
dat_farm_conf <- merge(dat_farm_conf, dat_pop1[, c("idp", "start")], all.x = TRUE)
#Filter only those in cohort entry (confirmar!!)
dat_farm_conf <- dat_farm_conf[start %within% interval(dat, d_end),]
#Medication by patient
dat_farm_conf <- dat_farm_conf[, .(hypnotics = case_when(any(hypnotics) ~ 1, TRUE ~ 0),
benzo = case_when(any(benzo) ~ 1, TRUE ~ 0),
ssri = case_when(any(ssri) ~ 1, TRUE ~ 0),
anticonv = case_when(any(anticonv) ~ 1, TRUE ~ 0)), by = "idp"]
cols <- c("hypnotics", "benzo", "ssri", "anticonv")
dat_farm_conf[, (cols) := lapply(.SD, function(x) factor(x, levels = 0:1, labels = c("No", "Yes"))), .SDcols = cols]
#Let's exclude them from the database to analyze (ens baixa a la meitat la capacitat de la bbdd). No els hem de considerar
dat_farm <- dat_farm[agr != "CONFUS"]
rm(list = ls())
library("devtools")
library(roxygen2)
setwd(r"(I:\CTebe\2_Projectes\2024_02Flowchart\3_CodiR\flowchart)")
#To create the package: https://www.r-bloggers.com/2020/07/how-to-write-your-own-r-package-and-publish-it-on-cran/
#1. Create an R project to a new existing directory and select R package
#2. Write a script for each function providing all information.
#3. Write a script for each built-in dataset, and save them in a data/ folder.
#4. Copy the license MIT file (from an existing package or https://www.r-project.org/Licenses/) and add this to .Rbuildignore: ^LICENSE\.md$
#5. Modify DESCRIPTION.md with the information about this package.
#6. Write a NEWS.md in which we will write the news from each update: usethis::use_news_md()
#7. Write a vignette: usethis::use_vignette("NAME_VIGNETTE")
#8. Specify all of the packages that we have to use:
# purrr::map(c("Gmisc", "grid", "tidyr", "dplyr", "purrr", "stringr", "tibble", "rlang"), usethis::use_package)
#usethis::use_pipe()
# Follow the next steps (we will also have to follow them in each update):
devtools::document()
devtools::check()
load("I:/CTebe/2_Projectes/2024_02Flowchart/3_CodiR/flowchart/data/clinic_patient.rda")
clinic_patient
devtools::document()
devtools::check()
