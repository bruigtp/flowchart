fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_filter(pp == 1, label = "Included in per-protocol\n population") |>
fc_draw()
rm(list = ls())
library(flowchart)
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_filter(pp == 1, label = "Included in per-protocol\n population") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_filter(pp == 1, label = "Included in per-protocol\n population") |>
fc_draw()
rm(list = ls())
library(flowchart)
?flowchart
?fc_draw
fc_draw
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_filter(pp == 1, label = "Included in per-protocol\n population") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_filter(pp == 1, label = "Included in per-protocol\n population") |>
fc_draw()
install.packages("I:/CTebe/2_Projectes/2024_02Flowchart/4_Productes/Versiones - Paquete/flowchart_0.2.0.tar_gif.gz", repos = NULL)
install.packages("I:/CTebe/2_Projectes/2024_02Flowchart/4_Productes/Versiones - Paquete/flowchart_0.2.0.tar_gif.gz", repos = NULL, type = "source")
library(flowchart)
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized") |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized") |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized") |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_filter(pp == 1, label = "Included in per-protocol\n population") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligiblity") |>
fc_filter(!is.na(group), show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group)) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_draw()
safo |>
as_fc("Patients assessed for eligibility") |>
fc_filter(!is.na(group), label = "Randomized", show_exc = TRUE) |>
fc_split(group) |>
fc_filter(itt == 1, label = "Included in intention-to-treat\n population") |>
fc_filter(pp == 1, label = "Included in per-protocol\n population") |>
fc_draw()
find_transitive_minR <- function(package) {
db <- tools::CRAN_package_db()
recursive_deps <- tools::package_dependencies(
package,
recursive = TRUE,
db = db
)[[1]]
# These code chunks are detailed below in the 'Minimum R dependencies in CRAN
# packages' section
r_deps <- db |>
dplyr::filter(Package %in% recursive_deps) |>
# We exclude recommended pkgs as they're always shown as depending on R-devel
dplyr::filter(is.na(Priority) | Priority != "recommended") |>
dplyr::pull(Depends) |>
strsplit(split = ",") |>
purrr::map(~ grep("^R ", .x, value = TRUE)) |>
unlist()
r_vers <- trimws(gsub("^R \\(>=?\\s(.+)\\)", "\\1", r_deps))
return(max(package_version(r_vers)))
}
find_transitive_minR("REDCapDM")
find_transitive_minR("flowchart")
rm(list=ls())
########################
#Llibreries
########################
library(tidyr)
library(tibble)
library(dplyr)
library(purrr)
library(stringr)
library(lubridate)
library(janitor)
library(openxlsx)
library(data.table)
library(forcats)
########################
## Funcions
########################
setwd('S:/Bioestadistica/2023_11ENegredo')
########################
## Directoris
########################
dades<-"./2_Dades/1_Originals"
dades_ana<-"./2_Dades/2_Analisi"
#Load REDCapDM for data preprocessing. It is a modification of the version 0.7.0 (recalculate function didn't work)
# install.packages(r"(I:\CTebe\2_Projectes\2023_03REDCapDM\4_Productes\Versiones - Paquete\REDCapDM_v070_pau)", repos = NULL, type = "source") #To install it. Before, it is important to unistall it
library(REDCapDM)
#------Import----------
#Diccionari
dic <- readxl::read_excel(file.path(dades, "OVER50_Dictionary.xlsx"))
#Informació registre participants
ds_registre <- redcap_data(
data_path = r"(S:\Bioestadistica\2023_11ENegredo\2_Dades\1_Originals\RegistreParticipants\OVER50IMAGING-DMExportBBDDRegistro_R_2023-12-11_1258.R)",
dic_path = r"(S:\Bioestadistica\2023_11ENegredo\2_Dades\1_Originals\OVER50_Dictionary.xlsx)"
)
ds_registre$dictionary <- dic %>%
filter(`Variable / Field Name` %in% names(ds_registre$data))
ds_registre$event_form <- tibble(
arm_num = 1,
unique_event_name = unique(ds_registre$data$redcap_event_name),
form = unique(ds_registre$dictionary$`Form Name`)
)
#Valoracions 1 i 2
#Hem de comentar una línea del codi R perquè peta (quan creem la variable 'frec_perd_orina_inc.factor')
#Hi ha menys etiquetes que valors diferents... 4 levels i només 3 són especificats ("No especificado","Una vez por sem o menos",">Una vez/sem pero 60 min")
ds_valoracions <- redcap_data(
data_path = r"(S:\Bioestadistica\2023_11ENegredo\2_Dades\1_Originals\Valoracions\OVER50IMAGING-DMExportBBDDValoraci_R_2023-12-11_1302.R)",
dic_path = r"(S:\Bioestadistica\2023_11ENegredo\2_Dades\1_Originals\OVER50_Dictionary.xlsx)"
)
ds_valoracions$dictionary <- dic %>%
filter(`Variable / Field Name` %in% names(ds_valoracions$data))
ds_valoracions$event_form <- tibble(
expand.grid(
arm_num = 1,
unique_event_name = unique(ds_valoracions$data$redcap_event_name),
form = unique(ds_valoracions$dictionary$`Form Name`)
)
) %>%
arrange(unique_event_name)
#Medicació concomitant
ds_med <- redcap_data(
data_path = r"(S:\Bioestadistica\2023_11ENegredo\2_Dades\1_Originals\MedicacioConcomitant\OVER50IMAGING-DMExportBBDDMedicaci_R_2023-12-11_1258.R)",
dic_path = r"(S:\Bioestadistica\2023_11ENegredo\2_Dades\1_Originals\OVER50_Dictionary.xlsx)"
)
ds_med$dictionary <- dic %>%
filter(`Variable / Field Name` %in% names(ds_med$data))
ds_med$event_form <- tibble(
expand.grid(
arm_num = 1,
unique_event_name = unique(ds_med$data$redcap_event_name),
form = unique(ds_med$dictionary$`Form Name`)
)
) %>%
arrange(unique_event_name)
dataset <- list(
data = NULL,
dictionary = NULL,
event_form = NULL
)
vars <- intersect(intersect(names(ds_registre$data), names(ds_valoracions$data)), names(ds_med$data))
#Les variables 'redcap_repeat_instrument' i 'redcap_repeat_instance' es troben en diferents formats, ja que el formulari de medicació concomitant és l'únic que té instruments repetits.
ds_registre$data <- ds_registre$data %>%
mutate(
redcap_repeat_instrument = as.character(redcap_repeat_instrument),
redcap_repeat_instance = as.integer(redcap_repeat_instance)
)
ds_valoracions$data <- ds_valoracions$data %>%
mutate(
redcap_repeat_instrument = as.character(redcap_repeat_instrument),
redcap_repeat_instance = as.integer(redcap_repeat_instance)
)
ds_med$data <- ds_med$data %>%
mutate(
redcap_repeat_instrument = as.character(redcap_repeat_instrument),
redcap_repeat_instance = as.integer(redcap_repeat_instance)
)
data <- ds_registre$data %>%
full_join(ds_valoracions$data, by = vars) %>%
full_join(ds_med$data, by = vars) %>%
mutate(
redcap_repeat_instance2 = case_when(
is.na(redcap_repeat_instance) ~ 0,
TRUE ~ redcap_repeat_instance
)
) %>%
arrange(redcap_data_access_group, record_id, redcap_event_name, redcap_repeat_instance2) %>%
dplyr::select(-redcap_repeat_instance2)
dataset$data <- data
#Transform the names of the dictionary to the transformed names
names(dic) <- janitor::make_clean_names(names(dic))
names(dic)[1] <- "field_name"
if (dic[1,1]!="record_id") {
dic[1,1] <- "record_id"
}
dataset$dictionary <- dic
event_form <- rbind(ds_registre$event_form, ds_valoracions$event_form, ds_med$event_form)
dataset$event_form <- event_form
#------Pre-processing-----
# Steps of the preprocess of rd_transform:
## Save labels in an object and remove them from the dataset
labels <- Hmisc::label(data)
data <- data %>% dplyr::mutate_all(function(x) {
class(x) <- setdiff(class(x), "labelled")
# attr(x, "label") <- NULL
x
})
# #Create variables for missing values of categorical variables with unknown levels
miss_var <- function(x) {
y <- case_when(
x %in% c("NASK", "UNK", "NA", "NAVU", "ND", "PED") ~ 1,
TRUE ~ 0
)
factor(y, levels = 0:1, labels = c("No", "Yes"))
}
snames_unk <- names(data)[map_lgl(names(data), ~any(c("NASK", "UNK", "NA", "NAVU", "ND", "PED") %in% data[[.x]]))]
data <- data %>%
mutate(
across(snames_unk, miss_var ,.names = "unknown_{col}")
)
#Add them to the var_lab (one time):
# var_lab <- readxl::read_excel("3_CodiR/var_lab.xlsx")
# add <- tibble(var = grep("^unknown_", names(data), value = TRUE), lab = "Unknown") %>%
#   filter(!var %in% var_lab$var)
# var_lab <- var_lab %>%
#   full_join(add, by = c("var", "lab"))
# openxlsx::write.xlsx(var_lab, file = "3_CodiR/var_lab.xlsx")
#Change integer variables that are read as character to numeric
vars_int <- dic %>%
filter(text_validation_type_or_show_slider_number == "integer") %>%
pull(field_name)
data <- data %>%
mutate_at(vars_int, as.integer)
#Change numeric variables that are read as character to integer
vars_num <- dic %>%
filter(text_validation_type_or_show_slider_number == "number") %>%
pull(field_name)
data <- data %>%
mutate_at(vars_num, as.numeric)
recalc <- REDCapDM:::recalculate(data, dic, event_form)
data <- recalc$data
dic <- recalc$dic
### See the results of the recalculation:
str_glue("{recalc$results}")
## Transforming checkboxes:
### First, we identify them and remove the factor version
var_check <- names(data)[grep("___", names(data))]
var_check_factors <- var_check[grep(".factor$", var_check)]
data <- data %>% dplyr::select(-tidyselect::all_of(var_check_factors))
var_check <- var_check[!grepl(".factor$", var_check)]
### If there are some in our dataset:
if (length(var_check) > 0) {
#### For checkboxes that have a branching logic we have two options, either we replace the values to missing when the   logic is missing (option A) or when the logic is missing and also isnt satisfied (option B). For option A use           checkbox_na = FALSE. For option B use checkbox_na = TRUE
checkbox_na <- TRUE
trans <- REDCapDM:::transform_checkboxes(data, dic, event_form, checkbox_na)
data <- trans$data
#### To see the results of this transformation:
str_glue("{trans$results}")
#Change the names to the names of the options and the values to No/Sí
checkbox_labels <- c("No", "Sí")
data <- data %>% dplyr::mutate(dplyr::across(tidyselect::all_of(var_check),
~factor(.x, levels = 0:1, labels = checkbox_labels)))
data_dic <- REDCapDM:::checkbox_names(data, dic, labels, checkbox_labels)
data <- data_dic$data
dic <- data_dic$dic
}
# #Write data dictionary
# var_lab <- dic %>%
#   dplyr::select(var = field_name, lab = field_label, form =  form_name, field_type, text_validation_type_or_show_slider_number)
#
# openxlsx::write.xlsx(var_lab, file = "3_CodiR/var_lab.xlsx")
#Mutate factor labels:
data <- data %>%
mutate(
tiempo_dorm_pit.factor = factor(tiempo_dorm_pit.factor, levels = 0:3, labels = c("<0 a 15 min", "16-30 min", "31-60 min", "> 60 min"))
)
#Sink the R script containing the transformation to factor to a character string It's needed in order to get which numeric value corresponds each category of the score
r_code <- readLines(file.path(dades, "Valoracions/OVER50IMAGING-DMExportBBDDValoraci_R_2023-12-11_1302.R"))
#For score variables we put the category puntuation with respect to the score between parentheses
pun_score <- function(x) {
#Extract the levels from the r script
code <- grep(str_glue("\\${cur_column()}"), r_code, value = TRUE)[1]
code <- gsub(".*levels=", "", code)
pun <- as.numeric(unlist(str_extract_all(code, "\\d+")))
levels(x) <- str_glue("{levels(x)} ({pun})")
x
}
#FAC score doesn't have any puntuation so we don't perform this transformation
vars_scores <- dic %>%
filter(field_type %in% c("yesno", "radio"), form_name %in% c("barthel", "lawton_activitades_vida_diaria", "deficiencia_auditiva", "incontinencia_urinaria", "pittsburg_sueo", "pfeiffer", "fried", "sppb", "clinical_frailty_scale", "mna_mini_nutritional_assessment", "deteccin_de_ancianos_de_riesgo_barber", "riesgo_hogar", "escala_de_recursos_sociales_oars", "sindromes_geritricos", "actividad_fsica", "frax", "psicologia"), !field_name %in% c("neu_real_psi", "neu_psi")) %>%
mutate(field_name = str_glue("{field_name}.factor")) %>%
pull(field_name)
data <- data %>%
mutate(
across(
all_of(vars_scores),
pun_score
)
)
table(data$d1_psi.factor)
table(data$d2_psi.factor)
table(data$d1_psi.facotr, data$d2_psi.factor)
table(data$d1_psi.factor, data$d2_psi.factor)
table(data$d1_psi.factor)
levels(data$d1_psi.facotr)
levels(data$d1_psi.factor)
table(data$d1_psi)
table(data$d2_psi)
find_transitive_minR("REDCapDM")
find_transitive_minR <- function(package) {
db <- tools::CRAN_package_db()
recursive_deps <- tools::package_dependencies(
package,
recursive = TRUE,
db = db
)[[1]]
# These code chunks are detailed below in the 'Minimum R dependencies in CRAN
# packages' section
r_deps <- db |>
dplyr::filter(Package %in% recursive_deps) |>
# We exclude recommended pkgs as they're always shown as depending on R-devel
dplyr::filter(is.na(Priority) | Priority != "recommended") |>
dplyr::pull(Depends) |>
strsplit(split = ",") |>
purrr::map(~ grep("^R ", .x, value = TRUE)) |>
unlist()
r_vers <- trimws(gsub("^R \\(>=?\\s(.+)\\)", "\\1", r_deps))
return(max(package_version(r_vers)))
}
find_transitive_minR("gtsummary")
find_transitive_minR("flowchart")
find_transitive_minR("REDCapDM")
rm(list = ls())
library("devtools")
library(roxygen2)
setwd(r"(I:\CTebe\2_Projectes\2024_02Flowchart\3_CodiR\flowchart)")
devtools::check()
devtools::check()
devtools::check()
devtools::check()
